\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[latin1]{inputenc}
\usepackage{listings}
\usepackage{color}
\allowdisplaybreaks

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=Java,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3,
	frame=single
}

\title{Boing}
\author{Alexander Winter}
\date{October 16, 2017}

\begin{document}
\maketitle
	
\newpage

\begin{lstlisting}
Collision detectCollision(Limit a, Limit b)
{
	if(a.normal.dot(b.normal) != -1)
		return null;
	
	Vector compA = a.pos;
	Vector compB = b.pos;
	//compare values to check if collision occurs, if the other is getting away from the first,
	// his velocity is subtracted to see if any collision could occur in the case where the one getting away gets pushed back on the first
	float compAx = posAx, compAy = posAy, compBx = posBx, compBy = posBy;

	//if the velocity is not going along the normal (going against the direction limit is pointing at)
	if(signum(a.normal.x) != signum(a.vel.x))
		//remove the velocity to feel the other body as it isn't moving
		compA.x -= a.vel.x;

	//per component
	if(signum(a.normal.y) != signum(a.vel.y))
		compAy -= a.vel.y;

	//same for B, B's normal is the opposite of A
	if(signum(b.normal.x) != signum(b.vel.x))
		compBx -= b.vel.x;

	if(signum(b.normal.y) != signum(b.vel.y))
		compBy -= b.vel.y;

	//if collision shifting is going along it's normal
	if(signum(a.normal.x) == signum(a.shift.x))
		//then expect it to be pushed to there this frame too
		//(we assume its getting pushed by something)
		vecA.x += a.shift.x;
	//else, collision shifting is going in the other direction
	//ignoring it is safer since we don't know for sure if
	//it will get pushed this frame too or if the pusher is B
	//(in the case were the pusher is B, this collision must happen
	//for the pushing not to drop)
	
	Vector vecA = a.vel;
	Vector vecB = b.vel;
	
	//collision shifting is per component
	if(signum(a.normal.y) == signum(a.shift.y))
		vecA.y += shiftA.y;

	//same for B, B's normal is the opposite of A
	if(signum(b.normal.x) == signum(b.shift.x))
		vecB.x += shiftB.x;

	if(signum(b.normal.y) == signum(b.shift.y))
		vecB.y += shiftB.y;
	//if b with his movement isn't after a with his movement
	//(aka the limits are still facing each other after having moved)
	if(compAx * a.normal.x + compAy * a.normal.y < compBx * a.normal.x + compBy * a.normal.y)
		return null;

	//'previous' position is assumed to be the current position minus
	//the fake movement we just assumed. This fake previous position is
	//used to make sure no collision drops by collision shitfing
	float prevAx = a.pos.x - vecAx;
	float prevAy = a.pos.y - vecAy;
	float prevBx = b.pos.x - vecBx;
	float prevBy = b.pos.y - vecBy;

	//if b isn't before a
	//(aka the limits at previous positions are not even facing each other)
	if(prevAx * a.normal.x + prevAy * a.normal.y > prevBx * a.normal.x + prevBy * a.normal.y) //if b isn't before a
		return null; //no collision

	float hsizeA = a.size / 2; //half size for A
	float hsizeB = b.size / 2; //half size for B

	float diff = ((b.pos.x - vecBx) - (a.pos.x - vecAx)) * normalX + ((b.pos.y - vecBy) - (a.pos.y - vecAy)) * normalY;
	float vecDiff = (vecBx - vecAx) * a.normal.x + (vecBy - vecAy) * a.normal.y;

	float midpoint = vecDiff != 0 ? (diff + vecDiff) / vecDiff : 0f;

	float midAx = a.pos.x - vecAx * midpoint; //midpoint x for A
	float midAy = a.pos.y - vecAy * midpoint; //midpoint y for A
	float midBx = b.pos.x - vecBx * midpoint; //midpoint x for B
	float midBy = b.pos.y - vecBy * midpoint; //midpoint y for B

	//contact surface, used to detect if limits are on the same plane and
	//to fullfill the collision report
	//get surface contact at mid point
	float surface = getContactSurface(midAx, midAy, hsizeA, midBx, midBy, hsizeB, a.normal.x, a.normal.y);

	//if 0, it might be a corner corner case
	if(surface < 0)
		return null;

	Collision collision;
	collision.normal = { normalX, normalY };

	collision.penetration = (cA, cB) -> getPenetration((Limit)cA, (Limit)cB);

	//boing v2 priority algorithm
	//collision.priority = surface * getPenetration(compAx, compAy, compBx, compBy, normalX, normalY);
	collision.priority = surface * getPenetration(a, b);
	//System.out.println(collision.priority);

	//re-get the position from the original calculation
	//since we are in a CollisionDynamicVariable, posAx, posAy etc. might
	//be outdated (cached values)
	collision.contactSurface = (cA, cB) -> getContactSurface((Limit)cA, (Limit)cB);

	collision.a = a;
	collision.b = b;

	return collision;
}
\end{lstlisting}

\end{document}